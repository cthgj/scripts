use Carp;
use Data::Dumper;
$Data::Dumper::Indent = 1;
##############################################################
# Run uniprot_map.pl, splitting large queries into 	     #
# smaller ones. The first argument must be a hash of	     #
# hashes whose keys are types of ids and whose values	     #
# are ids: $to_map{RefSeq}{NP_12345}.			     #
# Returns two hashes:		 			     #
#     %{$mapped{$id}}, %{$not_mapped{$id}}	 	     #
##############################################################
sub map_from_UniProt{
    my $hash=shift();
    my %to_map=%{$hash};
    my $to_id=shift()||"ID";
    my $species=shift()||"unknown_spc";
    my $tmp_dir=shift()||"/tmp";
    my $spacer=shift();
    $spacer or do {$spacer="\t"};
    my (%mapped_ids, %not_mapped);
    ####################################################
    # Since some psicquic id lines have >1 type of id  #
    # sort %to_map according to the number of ids of   #
    # each $from. That way, we minimise the chances of #
    # searching for the same id twice.		       #
    ####################################################
    my @froms=sort{
	if($a eq 'UNK'){return 1}
	elsif($b eq 'UNK'){return -1}
	else{
	    return(scalar(keys(%{$to_map{$b}})) <=> scalar(keys(%{$to_map{$a}})));
	}
    } keys(%to_map);
    foreach my $from (@froms){## For each type of ID
	next if $from eq 'REV';
	next if $from eq 'UNK';
	my @missing;
	#print STDERR Dumper(\%to_map);
	my %k;
	my $counter=0;
	map{
	    ##################################################
            # Skip if this id has already been mapped	     #
            ##################################################
	    #print "YES : $_ : $mapped_ids{$_}\n" if defined($mapped_ids{$_});
	    next if defined($mapped_ids{$_});
	    $counter++;
	    $k{$to_map{$from}{$_}}++; ## avoid duplicates
	    push @missing, $to_map{$from}{$_} unless $k{$to_map{$from}{$_}}>1;
	}keys(%{$to_map{$from}});
	next unless $counter>0;
	my @files=("$tmp_dir/names.$$.$from.$species.0");
	open(my $fh,">", "$files[$#files]") or croak "cannot open $files[$#files] > : $!";
	$counter=0;
	my $cc=0;
	foreach my $missing_id (@missing){
	    #####################################################
            # Skip this id if it has already been mapped        #
            #####################################################
	    unless (defined($mapped_ids{$to_map{REV}{$missing_id}})){
		print $fh "$missing_id\n" ;
		$counter++;
		#########################################################
		# If there are MANY ids, break the uniprot query        #
		# into smaller ones.				        #
		#########################################################
		if($counter>1 && $counter % 2000 == 0){
		    $cc++;
		    close $fh;
		    debug("Opening $missing_id : $counter $tmp_dir/names.$$.$from.$species.$cc");
		    push @files, "$tmp_dir/names.$$.$from.$species.$cc";
		    open($fh,">", "$files[$#files]") or croak "cannot open $files[$#files] > : $!";
		    $counter=0;
		}
	    }
	}
	close $fh;
	####################
	# Get from UniProt #
	####################
	my $tt=$#files+1;
	for my $num (1..$tt){
	    my $cmd="uniprot_map.pl -";
	    $verbose && do {$cmd.="v"};
	    $cmd.="f $from -t $to_id $files[$cc]";
	    my $cc=$num-1;
	    my $file=$files[$cc];
	    v_say("$from : uniprot_map.pl -f $from -t $to_id $files[$cc]\n\t\t",$spacer, 1);
	    my $map=`$cmd`;
	    ########################################################
	    # Read the mapped names into a hash and convert        #
	    ########################################################
	    my %l;
	    map{
		my @a=split(/\t/);
		####################################################
		# UniProt sometimes returns the SAME line twice	   #
		####################################################
		push @{$l{$a[0]}},$a[1];
	    }split("\n",$map);
	    ##########################################################
	    # Now build a hash connecting the original (bad) id      #
	    # to the mapped one					     #
	    ##########################################################
	    foreach my $orig_id (keys(%{$to_map{$from}})){   
		if(defined($l{$to_map{$from}{$orig_id}})) {
		    $mapped_ids{$orig_id}=$l{$to_map{$from}{$orig_id}};
		}
		else{$not_mapped{$orig_id}++}
	    }
	}
    }
    my @a=keys(%mapped_ids);
    my @b=keys(%not_mapped);
    return(\%mapped_ids, \%not_mapped);
}
########################################################
# Check if output files exist, prompt user for action  #
########################################################
sub check_files{
  foreach my $f (@_){
      -e $f && do { 
	  print STDERR "\n\tThere is already a file called $f, continuing will overwrite it. Continue? [Y/n]: ";
	  my $a=0;
	  while($a==0){
	      my $resp=<STDIN>;
	      if($resp eq "\n" || $resp =~ /^\s*[yY]\s*$/){$a=1;}
	      elsif($resp =~ /^\s*[nN]\s*$/){exit;}
	      else{print STDERR "Please type Y or N\n"}
	  }
	  print STDERR "\t*** Running the script with the '-F' flag will automatically overwrite any existing files ***\n";
      }
  }
}
###############################################
# Will print the 1st ARG passed to STDERR iff #
# global $debug is set			      #
###############################################
sub debug(){
    my $msg=shift;
    $msg.="\n" unless $msg=~/\n$/;
    print STDERR "\tDEBUG: $msg" if $debug; 
}

###############################################################
# v_say can take up to 3 arguments. The first arg will be     #
# printed to STDERR with a \n appended unless one is already  #
# there. Any STRING passed will be prepended to the output.   #
# Any NUMBER passed will cause v_say to NOT append a \n to    #
# its output.						      #
###############################################################
sub v_say(){
    return() unless $verbose;
    my $msg=shift();
    my ($spacer, $nl);
    ##################################
    # If there are 2 more arguments. #
    ##################################
    if($#_>0){
	$nl=1;
	# If $_[0] is a num and $_[1] is a string
	if (!($_[0] & ~$_[0]) && ($_[1] & ~$_[1])){
	    $spacer=$_[1];
	}
	# If $_[1] is a num and $_[0] is a string
	elsif(!($_[1] & ~$_[1]) && ($_[0] & ~$_[0])){
	    $spacer=$_[0];
	}
	else{croak "If 3 args are given to v_say, two must be strings and one must be a number.\n"  }
    }
    ######################################################
    # If there is only 1 more argument, if the arg is 	 #
    # a string it will be the spacer. If it is 0 it will #
    # cause v_say to NOT add a \n at the end of $msg.	 #
    ######################################################
    else{
	####################################################
        # If there are no more arguments, 	 	   #
	# print and exit.				   #
        ####################################################
	unless ($_[0]){
	    $msg.="\n" unless $msg=~/\n$/;
	    print STDERR "$msg" ;
	    return(); 
	}
	## If $_[0] is a number
	if (!($_[0] & ~$_[0])){
	    $nl=1;
	}	
	else{$spacer=$_[0];}
    }
    !$nl && do{$msg.="\n" unless $msg=~/\n$/;};
    $msg=~s/^\t//;
    $spacer||="" ;
    print STDERR $spacer, "$msg"; 
    return(); 
}
##########################################################
# Will print the 1st ARG passed to STDERR piped through  #
# more and then exit. It will also trim $0 to get the 	 #
# program name.	If no 2nd arg is passed, it will pipe    #
# through more, otherwise through less.                  #
##########################################################
sub print_help_exit(){
    my %msg=%{shift()};
    my $H;
    open ($H, "| more") or croak "Could not open HELP file: $!\n";
    $0=~/.+?([^\/]+)$/;
    my $a=$1;
    $msg{'desc'}=~s/$0/$a/;
    print $H "$msg{desc}\n\n";
    my @opts=sort grep(!/desc|usage/, keys(%msg));
    print $H <<EndOfHelp;
USAGE: 
\t$a $msg{'usage'}

OPTIONS:
EndOfHelp
    
    map{
	$msg{$_}=fold_at_word($msg{$_}, 70, "\n\t     ");
	print $H "\t-$_ : $msg{$_}\n"
    }@opts;
    exit;
}

##############################################
# This will return a species name if known.  #      
##############################################
sub get_species{
    my $species=shift();
    $spc_opt=shift()|| "-s";
    if   (($species eq "human") || 
	  ($species eq "hum") || 
	  ($species eq "hs")){
	$species='human';
    }
    elsif(($species eq "fly")   || 
	  ($species eq "fb")  || 
	  ($species eq "dm") || 
	  ($species eq "dro")){
	$species='fly';
    }
    elsif(($species eq "worm")  || 
	  ($species eq "wb")  || 
	  ($species eq "ce") || 
	  ($species eq "ele")){
	$species='worm';
    }
    elsif(($species eq "mouse") || 
	  ($species eq "mg")  || 
	  ($species eq "mm") || 
	  ($species eq "mus")){
	$species='mouse';
    }
    elsif(($species eq "yeast") || 
	  ($species eq "sgd") || 
	  ($species eq "scc")){
	$species='yeast';
    }
        else{print STDERR   <<EndOfMsg;
Species ($spc_opt) must be one of the following:
         "human" || "hum" || "hs"
	 "fly"   || "fb"  || "dm" || "dro"
	 "worm"  || "wb"  || "ce" || "ele"
	 "mouse" || "mg"  || "mm" || "mus"
	 "yeast" || "sgd" || "scc"
EndOfMsg
	     exit(0);
    }
    return($species);
	


}
####################################################
# This will try and guess a species from a string. #
####################################################
sub guess_species{
    ###########################################################
    # The string (e.g. a filename) to search for a species in #
    ###########################################################
    my $fname=shift(); 

    if (($fname=~/\bhuman\b/) || 
	 ($fname=~/\bhum\b/) || 
	  ($fname=~/\bhs\b/)){
	      $species='human';
	  }
    elsif(($fname=~/\bfly\b/)   || 
	  ($fname=~/\bfb\b/)  || 
	  ($fname=~/\bdm\b/) || 
	  ($fname=~/\bdro\b/)){
	$species='fly';
    }
    elsif(($fname=~/\bworm\b/)  || 
	  ($fname=~/\bwb\b/)  || 
	  ($fname=~/\bce\b/) || 
	  ($fname=~/\bele\b/)){
	$species='worm';
    }
    elsif(($fname=~/\bmouse\b/) || 
	  ($fname=~/\bmg\b/)  || 
	  ($fname=~/\bmm\b/) || 
	  ($fname=~/\bmus\b/)){
	$species='mouse';
    }
    elsif(($fname=~/\byeast\b/) || 
	  ($fname=~/\bsgd\b/) || 
	  ($fname=~/\bscc\b/)){
	$species='yeast';
    }
    elsif($fname=~/([^\/]+).flata/){
	$species=$1;
    }
    elsif($fname=~/([^\/]+).psi/){
	$species=$1;
    }
    else{$species='unknown_spc';}
    return($species)
}

######################################################
# Fold a long string at specified length, respecting #
# word boundaries				     #
######################################################
sub fold_at_word{
    my $s=shift()|| croak "&fold_at_word needs 2 arguments";
    my $l=shift()|| croak "&fold_at_word needs 2 arguments";
    my $spacer=shift()|| "\n";
    return($s) if length($s)<=$l;
    my $ret="";
    my @a=split(/\s/, $s);
    my $L=1;
    foreach my $c (@a){
	$ret.="$c ";
	$L+=length($c);
	$L > $l && do {
	    $ret.="$spacer";
	    $L=0;
	}
    }
    return($ret);
}


##############################################################
# Get a list of accepted MIs (interaction detection methods) #
##############################################################
sub get_hq_MIs{
    my $mode=shift||'b';
    my %hq;
    if($mode eq 'b'){
	%hq=(
	    "MI:0008" => "array technology",
	    "MI:0009" => "bacterial display",
	    "MI:0010" => "beta galactosidase complementation",
	    "MI:0011" => "beta lactamase complementation",
	    "MI:0012" => "bioluminescence resonance energy transfer",
	    "MI:0013" => "biophysical",
	    "MI:0014" => "adenylate cyclase complementation",
	    "MI:0016" => "circular dichroism",
	    "MI:0017" => "classical fluorescence spectroscopy",
	    "MI:0018" => "two hybrid",
	    "MI:0020" => "transmission electron microscopy",
	    "MI:0030" => "cross-linking study",
	    "MI:0031" => "protein cross-linking with a bifunctional reagent",
	    "MI:0034" => "display technology",
	    "MI:0040" => "electron microscopy",
	    "MI:0041" => "electron nuclear double resonance",
	    "MI:0042" => "electron paramagnetic resonance",
	    "MI:0043" => "electron resonance",
	    "MI:0047" => "far western blotting",
	    "MI:0048" => "filamentous phage display",
	    "MI:0049" => "filter binding",
	    "MI:0051" => "fluorescence technology",
	    "MI:0052" => "fluorescence correlation spectroscopy",
	    "MI:0053" => "fluorescence polarization spectroscopy",
# "MI:0054" => "fluorescence-activated cell sorting",
	    "MI:0055" => "fluorescent resonance energy transfer",
	    "MI:0065" => "isothermal titration calorimetry",
	    "MI:0066" => "lambda phage display",
	    "MI:0073" => "mrna display",
	    "MI:0081" => "peptide array",
	    "MI:0084" => "phage display",
	    "MI:0089" => "protein array",
	    "MI:0090" => "protein complementation assay",
	    "MI:0091" => "chromatography technology",
	    "MI:0092" => "protein in situ array",
	    "MI:0095" => "proteinchip(r) on a surface-enhanced laser desorption/ionization",
	    "MI:0097" => "reverse ras recruitment system",
	    "MI:0098" => "ribosome display",
	    "MI:0099" => "scintillation proximity assay",
	    "MI:0107" => "surface plasmon resonance",
	    "MI:0108" => "t7 phage display",
	    "MI:0111" => "dihydrofolate reductase reconstruction",
	    "MI:0112" => "ubiquitin reconstruction",
	    "MI:0114" => "x-ray crystallography",
	    "MI:0115" => "yeast display",
	    "MI:0226" => "ion exchange chromatography",
	    "MI:0227" => "reverse phase chromatography",
	    "MI:0231" => "mammalian protein protein interaction trap",
	    "MI:0232" => "transcriptional complementation assay",
# "MI:0254" => "genetic interference",
	    "MI:0255" => "post transcriptional interference",
# "MI:0256" => "rna interference",
# "MI:0257" => "antisense rna",
	    "MI:0369" => "lex-a dimerization assay",
	    "MI:0370" => "tox-r dimerization assay",
	    "MI:0397" => "two hybrid array",
	    "MI:0398" => "two hybrid pooling approach",
	    "MI:0399" => "two hybrid fragment pooling approach",
	    "MI:0400" => "affinity technology",
	    "MI:0401" => "biochemical",
	    "MI:0405" => "competition binding",
	    "MI:0406" => "deacetylase assay",
	    "MI:0410" => "electron tomography",
	    "MI:0411" => "enzyme linked immunosorbent assay",
	    "MI:0415" => "enzymatic study",
	    "MI:0416" => "fluorescence microscopy",
	    "MI:0419" => "gtpase assay",
	    "MI:0420" => "kinase homogeneous time resolved fluorescence",
	    "MI:0423" => "in-gel kinase assay",
	    "MI:0424" => "protein kinase assay",
	    "MI:0425" => "kinase scintillation proximity assay",
	    "MI:0426" => "light microscopy",
	    "MI:0428" => "imaging technique",
# "MI:0430" => "nucleic acid uv cross-linking assay",
	    "MI:0432" => "one hybrid",
	    "MI:0434" => "phosphatase assay",
	    "MI:0435" => "protease assay",
	    "MI:0437" => "protein three hybrid",
# "MI:0438" => "rna three hybrid",
#"MI:0439" => "random spore analysis",
	    "MI:0440" => "saturation binding",
#"MI:0441" => "synthetic genetic analysis",
	    "MI:0508" => "deacetylase radiometric assay",
	    "MI:0509" => "phosphatase homogeneous time resolved fluorescence",
	    "MI:0510" => "homogeneous time resolved fluorescence",
	    "MI:0511" => "protease homogeneous time resolved fluorescence",
	    "MI:0512" => "zymography",
	    "MI:0513" => "collagen film assay",
	    "MI:0514" => "in gel phosphatase assay",
	    "MI:0515" => "methyltransferase assay",
	    "MI:0516" => "methyltransferase radiometric assay",
#"MI:0588" => "three hybrid",
	    "MI:0655" => "lambda repressor two hybrid",
	    "MI:0657" => "systematic evolution of ligands by exponential enrichment",
#"MI:0663" => "confocal microscopy",
	    "MI:0678" => "antibody array",
	    "MI:0695" => "sandwich immunoassay",
	    "MI:0696" => "polymerase assay",
# "MI:0697" => "dna directed dna polymerase assay",
# "MI:0698" => "dna directed rna polymerase assay",
# "MI:0699" => "rna directed dna polymerase assay",
# "MI:0700" => "rna directed rna polymerase assay",
	    "MI:0726" => "reverse two hybrid",
	    "MI:0727" => "lexa b52 complementation",
	    "MI:0728" => "gal4 vp16 complementation",
	    "MI:0809" => "bimolecular fluorescence complementation",
	    "MI:0813" => "proximity enzyme linked immunosorbent assay",
	    "MI:0824" => "x-ray powder diffraction",
	    "MI:0825" => "x-ray fiber diffraction",
	    "MI:0827" => "x-ray tomography",
	    "MI:0841" => "phosphotransferase assay",
	    "MI:0870" => "demethylase assay",
	    "MI:0872" => "atomic force microscopy",
	    "MI:0879" => "nucleoside triphosphatase assay",
	    "MI:0880" => "atpase assay",
	    "MI:0887" => "histone acetylase assay",
	    "MI:0889" => "acetylase assay",
	    "MI:0892" => "solid phase assay",
	    "MI:0894" => "electron diffraction",
	    "MI:0895" => "protein kinase A complementation",
	    "MI:0899" => "p3 filamentous phage display",
	    "MI:0900" => "p8 filamentous phage display",
	    "MI:0905" => "amplified luminescent proximity homogeneous assay",
	    "MI:0916" => "lexa vp16 complementation",
	    "MI:0920" => "ribonuclease assay",
	    "MI:0921" => "surface plasmon resonance array",
	    "MI:0946" => "ping",
	    "MI:0947" => "bead aggregation assay",
	    "MI:0949" => "gdp/gtp exchange assay",
	    "MI:0953" => "polymerization",
	    "MI:0968" => "biosensor",
	    "MI:0969" => "bio-layer interferometry",
	    "MI:0972" => "phosphopantetheinylase assay",
	    "MI:0976" => "total internal reflection fluorescence spectroscopy",
	    "MI:0979" => "oxidoreductase assay",
	    "MI:0984" => "deaminase assay",
	    "MI:0989" => "amidase assay",
	    "MI:0990" => "cleavage assay",
	    "MI:0991" => "lipid cleavage assay",
	    "MI:0992" => "defarnesylase assay",
	    "MI:0993" => "degeranylase assay",
	    "MI:0994" => "demyristoylase assay",
	    "MI:0995" => "depalmitoylase assay",
	    "MI:0996" => "deformylase assay",
	    "MI:0997" => "ubiquitinase assay",
	    "MI:0998" => "deubiquitinase assay",
	    "MI:0999" => "formylase assay",
	    "MI:1000" => "hydroxylase assay",
	    "MI:1001" => "lipidase assay",
	    "MI:1002" => "myristoylase assay",
	    "MI:1003" => "geranylgeranylase assay",
	    "MI:1004" => "palmitoylase assay",
	    "MI:1005" => "adp ribosylase assay",
	    "MI:1006" => "deglycosylase assay",
	    "MI:1007" => "glycosylase assay",
	    "MI:1008" => "sumoylase assay",
	    "MI:1009" => "desumoylase assay",
	    "MI:1010" => "neddylase assay",
	    "MI:1011" => "deneddylase assay",
	    "MI:1016" => "fluorescence recovery after photobleaching",
	    "MI:1019" => "protein phosphatase assay",
	    "MI:1024" => "scanning electron microscopy",
	    "MI:1026" => "diphtamidase assay",
	    "MI:1030" => "excimer fluorescence",
	    "MI:1031" => "protein folding/unfolding",
#"MI:1034" => "nuclease assay",
#"MI:1035" => "deoxyribonuclease assay",
	    "MI:1036" => "nucleotide exchange assay",
	    "MI:1037" => "Split renilla luciferase complementation",
	    "MI:1038" => "silicon nanowire field-effect transistor",
	    "MI:1087" => "monoclonal antibody blockade",
	    "MI:1088" => "phenotype-based detection assay",
	    "MI:1089" => "nuclear translocation assay",
	    "MI:1111" => "two hybrid bait or prey pooling approach",
	    "MI:1112" => "two hybrid prey pooling approach",
	    "MI:1113" => "two hybrid bait and prey pooling approach",
	    "MI:1137" => "carboxylation assay",
	    "MI:1138" => "decarboxylation assay",
	    "MI:1142" => "aminoacylation assay",
	    "MI:1145" => "phospholipase assay",
	    "MI:1147" => "ampylation assay"
	    );
    }
    return(\%hq);
}

sub print_hash{
    my %h=%{$_[0]};
    if($#_>0){
	map{print STDERR "$_\t$h{$_}\n"}keys(%h);
    }
    else{
	map{print STDOUT "$_\t$h{$_}\n"}keys(%h);
    }
}


1;
